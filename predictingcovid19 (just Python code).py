# -*- coding: utf-8 -*-
"""PredictingCovid19.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eCcM05mKTTJLkxkrJtWjXa3Bdm9yLG5K

# Predicting Covid-19 cases in France
Objectives: 
- use KNN algorithm to predict the evolution of infected and death. 
- use KNN algorithm to predict the decisions that a state should make to avoid the spreading of the virus

# Sample data preprocessing


1.   Add a new column representing id number
2.   Add a new column representing the slope of consecutive points
3.   Discard not so usefull columns
4.   Mapping the date column with a numerical value using an encoder
"""

import csv

in_file_path = '/content/test.csv'
out_file_path = 'res.csv'


with open(in_file_path) as in_csv_file, open(out_file_path, mode='w', newline='') as out_csv_file:
    reader = csv.reader(in_csv_file)
    writer = csv.writer(out_csv_file)

    prev_index, prev_row = 2, ['France', '1/2/2020', '0', '0', '0', '0', 2]
    for index, row in enumerate(reader):
        if index == 0 or index == 1:
          continue
        # print('linia curenta ' + str(row))
        #print('linia anterioara ' + str(prev_row))
        #last_elem_cur_row = row[-7]
        #print(str(row) + ' : ' + last_elem_cur_row)
        row.append(index)
        y2 = row[4]
        y1 = prev_row[4]
        row.append(int(y2)-int(y1))
        writer.writerow(row)

        prev_index, prev_row = index, row

import os
import subprocess
import pandas as pd
import numpy as np


input_file = "sampleProcessed.csv" #load modified dataset

myData = pd.read_csv(input_file, header = 0) 

myData.columns #verity all columns are loaded

myData.head() #print some of the data to visualize it

# To work faster, I discarded the columns i don't really need
# For example, the country is not a column that i need. I only analize the cases in France.
myData = myData.drop(myData.columns[0], axis=1)



myData.head()

#To make this work, I need to encode the date column, because there are no numerical values there. They are dates.
#For that, a label Encoder may be used.

from sklearn import preprocessing

labelEncoder = preprocessing.LabelEncoder()

labelEncoder.fit(myData['Date'])
myData.loc[:, 'Date'] = labelEncoder.transform(myData['Date'])

myData.head()

"""# Data splitting into train and test
I made prediction for every column (Confirmed, Death, New Confirmed, New Death)
"""

from sklearn.model_selection import train_test_split


y = myData.iloc[:, 1].values
y = y.reshape(-1,1)

X_usedValues = myData.iloc[:, 0:1].values #only selected the date and the confirmed column
#Split the date into training set and test set
X_train, X_test, y_train, y_test = train_test_split(X_usedValues, y, test_size=0.20)

print(len(X_train))
print(len(X_test))

myData #visualize the new Date column

#These is the training data
X_train

y_train

#This is the test data
X_test

y_test

"""# Making predictions
1.   4 graphical representation of the process 
2.   Real results from the prediction
3.   Comparison between expected and predicted values
4.   Evaluation metrics
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsRegressor

#Get prediction for number of confirmed persons

n_neighbors = 3 #Number of neighbors chosen is 3. I will also try with other values
for i, weights in enumerate(['uniform', 'distance']):
    knn = KNeighborsRegressor(n_neighbors, weights=weights, algorithm = 'brute', leaf_size = 60) #Initialize regressor
    y_result = knn.fit(X_train, y_train).predict(X_test) 
    #Plot a graph to visualize 
    plt.subplot(2, 1, i + 1)
    plt.scatter(X_train[:,0], y_train, color='darkorange', label='data')
    plt.plot(X_test[:,0], y_result, color='navy', label='prediction')
    plt.axis('tight')
    plt.legend()
    plt.title("KNeighborsRegressor (k = %i, weights = '%s')" % (n_neighbors,
                                                                weights))

plt.tight_layout()
plt.show()

#These are the values predicted. We can compare it by looking 2 text boxes above. It's pretty good.
y_result.astype(int)

#We can use different metrics to evaluate these predictions. I will use different algorithms and plot a visual comparison between them
from sklearn.metrics import explained_variance_score
explained_variance_score(y_test, y_result.astype(int))

from sklearn.metrics import max_error
max_error(y_test, y_result.astype(int))

from sklearn.metrics import mean_absolute_error
mean_absolute_error(y_test, y_result.astype(int))

from sklearn.metrics import mean_squared_error
mean_squared_error(y_test, y_result.astype(int))

from sklearn.metrics import mean_squared_log_error
mean_squared_log_error(y_test, y_result.astype(int))

from sklearn.metrics import median_absolute_error
median_absolute_error(y_test, y_result.astype(int))

from sklearn.metrics import r2_score
r2_score(y_test, y_result.astype(int))

#Do the same for the number of total deaths
y = myData.iloc[:, 2].values
y = y.reshape(-1,1)

X_usedValues = myData.iloc[:, 0:2].values

X_train, X_test, y_train, y_test = train_test_split(X_usedValues, y, test_size=0.20)


import numpy as np
import matplotlib.pyplot as plt

n_neighbors = 3
for i, weights in enumerate(['uniform', 'distance']):
    knn = KNeighborsRegressor(n_neighbors, weights=weights, algorithm = 'brute', leaf_size = 60)
    y_result = knn.fit(X_train, y_train).predict(X_test)

    plt.subplot(2, 1, i + 1)
    plt.scatter(X_train[:,1], y_train, color='darkorange', label='data')
    plt.plot(X_test[:,1], y_result, color='navy', label='prediction')
    plt.axis('tight')
    plt.legend()
    plt.title("KNeighborsRegressor (k = %i, weights = '%s')" % (n_neighbors,
                                                                weights))

plt.tight_layout()
plt.show()

#Expected values
y_test

#The prediction
y_result.astype(int)

#Do the same for the number of new confirmed
y = myData.iloc[:, 3].values
y = y.reshape(-1,1)

X_usedValues = myData.iloc[:, 0:2].values

X_train, X_test, y_train, y_test = train_test_split(X_usedValues, y, test_size=0.20)



import numpy as np
import matplotlib.pyplot as plt

n_neighbors = 3
for i, weights in enumerate(['uniform', 'distance']):
    knn = KNeighborsRegressor(n_neighbors, weights=weights, algorithm = 'brute', leaf_size = 60)
    y_result = knn.fit(X_train, y_train).predict(X_test)

    plt.subplot(2, 1, i + 1)
    plt.scatter(X_train[:,1], y_train, color='darkorange', label='data')
    plt.plot(X_test[:,1], y_result, color='navy', label='prediction')
    plt.axis('tight')
    plt.legend()
    plt.title("KNeighborsRegressor (k = %i, weights = '%s')" % (n_neighbors,
                                                                weights))

plt.tight_layout()
plt.show()

#Expected results
y_test

#The prediction
y_result.astype(int)

#Do the same for the number of new deaths
y = myData.iloc[:, 4].values
y = y.reshape(-1,1)

X_usedValues = myData.iloc[:, 0:2].values

X_train, X_test, y_train, y_test = train_test_split(X_usedValues, y, test_size=0.20)



import numpy as np
import matplotlib.pyplot as plt

n_neighbors = 3
for i, weights in enumerate(['uniform', 'distance']):
    knn = KNeighborsRegressor(n_neighbors, weights=weights, algorithm = 'brute', leaf_size = 60)
    y_result = knn.fit(X_train, y_train).predict(X_test)

    plt.subplot(2, 1, i + 1)
    plt.scatter(X_train[:,1], y_train, color='darkorange', label='data')
    plt.plot(X_test[:,1], y_result, color='navy', label='prediction')
    plt.axis('tight')
    plt.legend()
    plt.title("KNeighborsRegressor (k = %i, weights = '%s')" % (n_neighbors,
                                                                weights))

plt.tight_layout()
plt.show()

#Expected result
y_test

#The prediction
y_result.astype(int)



"""# KNN with different params"""

import os
import subprocess
import pandas as pd
import numpy as np


input_file = "sampleProcessed.csv" #load modified dataset

myData = pd.read_csv(input_file, header = 0) 

# To work faster, I discarded the columns i don't really need
# For example, the country is not a column that i need. I only analize the cases in France.
myData = myData.drop(myData.columns[0], axis=1)

from sklearn.model_selection import train_test_split
from sklearn import preprocessing

#To make this work, I need to encode the date column, because there are no numerical values there. They are dates.
#For that, a label Encoder may be used.
#Let's do it

labelEncoder = preprocessing.LabelEncoder()

labelEncoder.fit(myData['Date'])
myData.loc[:, 'Date'] = labelEncoder.transform(myData['Date'])


y = myData.iloc[:, 1].values
y = y.reshape(-1,1)

X_usedValues = myData.iloc[:, 0:1].values #only selected the date and the confirmed column
#Split the date into training set and test set
X_train, X_test, y_train, y_test = train_test_split(X_usedValues, y, test_size=0.20)

import numpy as np
import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsRegressor

#Get prediction for number of confirmed persons

import numpy as np
import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsRegressor

n_neighbors = 60
for i, weights in enumerate(['uniform', 'distance']):
    knn = KNeighborsRegressor(n_neighbors, weights=weights, algorithm = 'brute', leaf_size = 60)
    y_result = knn.fit(X_train, y_train).predict(X_test)

    plt.subplot(2, 1, i + 1)
    plt.scatter(X_train[:,0], y_train, color='darkorange', label='data')
    plt.plot(X_test[:,0], y_result, color='navy', label='prediction')
    plt.axis('tight')
    plt.legend()
    plt.title("KNeighborsRegressor (k = %i, weights = '%s')" % (n_neighbors,
                                                                weights))

plt.tight_layout()
plt.show()

from sklearn.metrics import max_error
max_error(y_test, y_result.astype(int))

from sklearn.metrics import mean_absolute_error
mean_absolute_error(y_test, y_result.astype(int))

from sklearn.metrics import mean_squared_error
mean_squared_error(y_test, y_result.astype(int))

from sklearn.metrics import mean_squared_log_error
mean_squared_log_error(y_test, y_result.astype(int))

from sklearn.metrics import median_absolute_error
median_absolute_error(y_test, y_result.astype(int))

from sklearn.metrics import r2_score
r2_score(y_test, y_result.astype(int))

"""# Evolution of Covid-19 and decision making using KNN
Based on the last column (slope calculated in the previous chapter), I can give an estimation of the situation in this country.
"""

import os
import subprocess
import pandas as pd
import numpy as np


input_file = "sampleProcessed.csv" #load modified dataset

myData = pd.read_csv(input_file, header = 0) 

# To work faster, I discarded the columns i don't really need
# For example, the country is not a column that i need. I only analize the cases in France.
myData = myData.drop(myData.columns[0], axis=1)

from sklearn.model_selection import train_test_split
from sklearn import preprocessing

#To make this work, I need to encode the date column, because there are no numerical values there. They are dates.
#For that, a label Encoder may be used.
#Let's do it

labelEncoder = preprocessing.LabelEncoder()

labelEncoder.fit(myData['Date'])
myData.loc[:, 'Date'] = labelEncoder.transform(myData['Date'])


myData

y = myData.iloc[:, 0].values
y

x = myData.iloc[:, 6].values
x

import matplotlib.pyplot as plt 

# A greater value on the height axis means an alarmating growth of the cases on that day
# We can give one of the following values depending on the state of the growth:
# - fara stare de urgenta sau alerta if growth < 300
# - stare de alerta if growth > 300 and growth < 700 for example
# - stare de urgenta if growth > 700 for example
# With these, the gouverment can take quick and great decisions for the state.  

plt.plot(y, x, label = "Evolution")

# Let's make an algorithm to predict this states
# First we need to add a new column with these values in the table

import csv

in_file_path = '/content/test.csv'
out_file_path = 'alertStates.csv'


with open(in_file_path) as in_csv_file, open(out_file_path, mode='w', newline='') as out_csv_file:
    reader = csv.reader(in_csv_file)
    writer = csv.writer(out_csv_file)

    prev_index, prev_row = 2, ['France', '1/2/2020', '0', '0', '0', '0', 2]
    for index, row in enumerate(reader):
        if index == 0 or index == 1:
          continue
        # print('linia curenta ' + str(row))
        #print('linia anterioara ' + str(prev_row))
        #last_elem_cur_row = row[-7]
        #print(str(row) + ' : ' + last_elem_cur_row)
        row.append(index)
        y2 = row[4]
        y1 = prev_row[4]
        row.append(int(y2)-int(y1))
        if int(y2)-int(y1) < 300:
          row.append(0)
        elif int(y2)-int(y1) > 700:
          row.append(2)
        else:
          row.append(1)
        writer.writerow(row)

        prev_index, prev_row = index, row

import os
import subprocess
import pandas as pd
import numpy as np


input_file = "alertStatesReady.csv" #load modified dataset

myData = pd.read_csv(input_file, header = 0) 

myData.columns #verity all columns are loaded

myData.head() #print some of the data to visualize it

# To work faster, I discarded the columns i don't really need
# For example, the country is not a column that i need. I only analize the cases in France.
myData = myData.drop(myData.columns[0], axis=1)
myData.head()

from sklearn.model_selection import train_test_split
from sklearn import preprocessing

#To make this work, I need to encode the date column, because there are no numerical values there. They are dates.
#For that, a label Encoder may be used.
#Let's do it

labelEncoder = preprocessing.LabelEncoder()

labelEncoder.fit(myData['Date'])
myData.loc[:, 'Date'] = labelEncoder.transform(myData['Date'])

#Do the same for the number of total deaths
y = myData.iloc[:, 7].values
y = y.reshape(-1,1)

X_usedValues = myData.iloc[:, 0:1].values

X_train, X_test, y_train, y_test = train_test_split(X_usedValues, y, test_size=0.20)

X_train

y_train

import numpy as np
import matplotlib.pyplot as plt

n_neighbors = 3
for i, weights in enumerate(['uniform', 'distance']):
    knn = KNeighborsRegressor(n_neighbors, weights=weights, algorithm = 'brute', leaf_size = 60)
    y_result = knn.fit(X_train, y_train).predict(X_test)

    plt.subplot(2, 1, i + 1)
    plt.scatter(X_train[:,0], y_train, color='darkorange', label='data')
    plt.plot(X_test[:,0], y_result, color='navy', label='prediction')
    plt.axis('tight')
    plt.legend()
    plt.title("KNeighborsRegressor (k = %i, weights = '%s')" % (n_neighbors,
                                                                weights))

plt.tight_layout()
plt.show()

#Expected results
y_test

#The prediction
y_result.astype(int)

